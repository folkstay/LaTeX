-- Изолированность (isolation)
/*
Во время выполнения транзакций, параллельные транзакции не должны оказывать влияние 
на её результат. Изолированность - дорогое и сложное требование.
В SQL SERVER существуют режимы, не полностью изолирующие транзакцию.
Для изоляции сервер реализует набор протоколов блокирования
Два основных режима блокирования:
1)совмещаемая блокировка (seared locks)
2)монопольная блокировка(exclusive locks)
Ситуация, когда несколько прикладных пользовательских программ одновременно
выполняют операции чтения и записи данных, называется одновременным конкурентным доступом(concurrency).
Компонент Database Engine поддерживает две модели конкурентного доступа:
- пессимистический одновременный конкурентный доступ (вероятен колнфликт -для предотвращения одновременного доступа применяются блокировки)
- оптимистический одновременный конкурентный доступ (конфликт моловероятен - строки видны на момент чтения и могут быть изменены, при попытке обращения к одним и тем же
данным система будет выдавать ошибку, которая обрабатывается клиентским приложением)

Блокировки удерживаются до конца транзакции, второй процесс переходит в состояние ожидания.(совместная блокировка зависит от уровня изоляции)
Взамоблокировки.(ошибка 1205)
К наиболее часто используемым уровням изоляции относятся
1)READ COMMITED(пессимистический) - по умолчанию - чтение только зафиксированные данные (проверка монопольной блокировки)
2)READ UNCOMMITED -  операции чтения игнорируют любые блокировки и могут читать данные которые обновлены  другой транзакцией
т.е возможно чтение незафиксированной транзакции (грязное чтение)
3)REPEATABLE READ - гарантирует, что данные прочитанные в транзакции, поздее могут быть снова прочитаны
(не допускается обновление и удаление уже прочитанных строк)блокировки удерживаются до конца транзакции, однако 
транзакция может видеть новые строки добавленные после чтения(фантомное чтение)
4)SERIALIZABLE - не допускает проблем конкурентного доступа(блокирование диапазона ключа, т.е блокирование индекса)
5)READ COMMITED SNAPSHOT(оптимистический)  - это дополнительный способ использования уровня по умолчанию
Использует  tmpdb для хранения версий измененных данных, позволяя читать данные в их исходном состоянии. Не нужны блокировки чтения на 
базовом ресурсе. Устанавливается на уровне БД.
6)SNAPSHOT - использует управление версиями строк в БД tmpdb.Устанавливается на уровне БД. Возможно повторение любой операции чтения
не будут доступны фантомные чтения.Новые сторки могут быть добавлены, но транзакция их не увидит. Не требуются блокировки чтения
*/

--Начальные условия
/*
-- Удаление записей в таблице
 TRUNCATE TABLE [Счета]
 GO
 --Добавление строк в таблицу
 INSERT INTO  [Счета]([Номер счета], [Владелец], [Баланс])
 VALUES ('1111111111111',N'Иванов',1000),
		('2222222222222',N'Петров',0)
GO
*/
--Проверка исходного состояния
SELECT * FROM [Счета]
-- Первый сеанс.Пессимистический бокирующий подход.
SET NOCOUNT ON;
SET TRANSACTION ISOLATION LEVEL  READ COMMITTED;
--Начинаем транзакцию(по- операторам)
BEGIN TRANSACTION;

UPDATE [Счета]
SET [Баланс]-=500
WHERE [Владелец]=N'Иванов'

SELECT * FROM [Счета]

select * from sys.dm_tran_locks
-- Переходим на 13.2 Второй сеанс для демонстрации READ UNCOMMITTED
-- Переходим на 13.3 Третий сеанс для демонстрации READ COMMITTED SNAPSHOT
-- Переходим на 13.4 Четвертый сеанс для демонстрации  SNAPSHOT



UPDATE [Счета]
SET [Баланс]+=500
WHERE [Владелец]=N'Петров'

--Фиксируем транзакцию
COMMIT TRANSACTION
GO
-- Откатываем транзакцию
--ROLLBACK TRANSACTION


--Можно вставить новую строку
 INSERT INTO  [Счета]([Номер счета], [Владелец], [Баланс])
 VALUES ('88888888888',N'Васечкин',3000)

 SELECT * FROM [Счета]